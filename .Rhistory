trunc(12.9888)
n = trunc(0.71001*N)
n
N = length(IBOV)
n = trunc(0.7*N)
train = IBOV[1:n, ]
train = IBOV[1:n]
View(train)
test = IBOV[n+1: N]
N
summary(test)
View(test)
IBOV[n+1]
test[1]
train_arima = auto.arima(train, lambda = 'auto')
predlen = length(test)
train_fit = forecast(train_arima, h=predlen)
plot(train_fit)
plot(mean_fit)
mean_fit = as.vector(train_fit$mean)
plot(mean_fit)
plot(mean_fit, type='l', col='red')
train_arima = auto.arima(train, lambda = 'auto')
predlen = length(test)
train_fit = forecast(train_arima, h=predlen)
plot(train_fit)
train_fit = forecast(train_arima, h=30)
plot(train_fit)
plot(train)
train_arima = auto.arima(train, lambda = 'auto')
train_arima
plot(mean_fit, type='l', col='red')
if(!require(rugarch)) install.packages("rugarch")
library('rugarch')
install.packages(mvtnorm)
install.packages('mvtnorm')
library('rugarch')
library('mvtnorm')
library(mvtnorm)
install.packages('mvtnorm')
library(mvtnorm)
library('rugarch')
garch = garch(IBOV, order=(1,1))
vol_ibov = garch(IBOV, order=(1,1))
vol_ibov = garch(IBOV, order=c(1,1))
summary(vol_ibov)
vol_ibov = garch(IBOV, order=c(2,1))
summary(vol_ibov)
View(vol_ibov)
plot(vol_ibov$fitted.values)
plot(vol_ibov$fitted.values, type='l')
vol_ibov = garch(IBOV, order=c(2,2))
summary(vol_ibov)
vol_ibov = garch(IBOV, order=c(1,1,2))
summary(vol_ibov)
vol_ibov = garch(IBOV, order=c(1,2))
summary(vol_ibov)
#------------------volatility models
garch11closeprice=ugarchspec(variance.model=list(garchOrder=c(1,1)), mean.model=list(armaOrder=c(1,2)))
#estimate model
garch11closepricefit=ugarchfit(spec=garch11closeprice, data=IBOV)
#estimate model
garch11closepricefit=ugarchfit(spec=garch11closeprice, data=IBOV)
plot.ts(sigma(garch11closepricefit), ylab="sigma(t)", col="blue")
#------------------volatility models
garch11closeprice=ugarchspec(variance.model=list(garchOrder=c(1,0)), mean.model=list(armaOrder=c(1,2)))
#estimate model
garch11closepricefit=ugarchfit(spec=garch11closeprice, data=IBOV)
#------------------volatility models
garch11closeprice=ugarchspec(variance.model=list(garchOrder=c(1,2)), mean.model=list(armaOrder=c(1,2)))
#estimate model
garch11closepricefit=ugarchfit(spec=garch11closeprice, data=IBOV)
#------------------volatility models
garch11closeprice=ugarchspec(variance.model=list(garchOrder=c(1,2)), mean.model=list(armaOrder=c(1,1)))
#estimate model
garch11closepricefit=ugarchfit(spec=garch11closeprice, data=IBOV)
#------------------volatility models
garch11closeprice=ugarchspec(variance.model=list(garchOrder=c(2,2)), mean.model=list(armaOrder=c(1,1)))
#estimate model
garch11closepricefit=ugarchfit(spec=garch11closeprice, data=IBOV)
library(quantmod)
library(fGarch)
getSymbols("^BVSP", src="yahoo", from="2015-01-01")
BVSP[:, 1:1]
BVSP[1:1]
BVSP[1:1, 1]
BVSP[1:1, 1:2]
BVSP[1:1, 4]
BVSP[1: , 4]
View(BVSP)
View(BVSP)
summary(BVSP)
basicStats(BVSP)
BVSP[1:1.268000e+03 , 4]
IBOV = BVSP[1:1.268000e+03 , 4]
garchFit(IBOV ~garch(1, 1), data = IBOV, trace = FALSE)
garchFit(IBOV ~garch(1, 1), data = IBOV)
garchFit(IBOV ~garch(1, 1), trace = FALSE)
vol = garchFit(IBOV ~garch(1, 1), trace = FALSE)
summary(vol)
fit =  fitted(vol)
plot(vol)
plot(fit)
plot(fit, type='l')
plot(fit, type='b')
plot(fit, type='l', col='b')
plot(fit, type='l', col='blue')
plot(fit, type='l', col='blue', ylab='Volatilidade')
plot(fit, type='l', col='blue', ylab='Volatilidade', main='Volatilidade do IBOV')
plot(fit, type='l', col='blue', ylab='Volatilidade',
main='Volatilidade do IBOV usando o GARCH(1,1)')
summary(vol)
View(BVSP)
View(IBOV)
library(xlsx)
install.packages(xlsx)
install.packages("xlsx")
library(xlsx)
write.xlsx(IBOV, file, sheetName="Sheet1")
as.numeric(rownames(BVSP))
dates = index(BVSP)
IBOV = ts(IBOV, index(dates))
View(IBOV)
IBOV = ts(IBOV, dates)
plot(IBOV)
plot(IBOV, dates)
View(dates)
View(dates[V1])
dates[V1]
dates[1, V1]
dates[1, v1]
View(dates[V1])
View(dates)
IBOV = ts(IBOV, dates)
IBOV = ts(IBOV, dates, frequency = 1)
IBOV = ts(IBOV, index(dates))
IBOV
index(IBOV)
df = data.frame(IBOV, dates)
View(df)
rownames(IBOV)= dates
View(IBOV)
rownames(df) = dates
View(df)
df['dates'] = NULL
plot(df)
View(df)
plot(df['BVSP.Close'])
plot(df['BVSP.Close'])
View(df)
plot(IBOV, dates)
plot(dates, IBOV)
plot(dates, IBOV, type='l')
rm(df)
fit =  fitted(vol)
summary(vol)
plot(fit, type='l', col='blue', ylab='Volatilidade',
main='Volatilidade do IBOV usando o GARCH(1,1)')
ar = arima(IBOV, order=c(1,1,1))
summary(ar)
ar
fit = fitted(ar)
fit =  fitted(vol)
fit2 = fitted(ar)
plot(fit2)
fit2 = fitted(ar, h=20)
fit2 = forecast(ar)
View(ar)
ar = auto.arima(IBOV, order=c(1,1,1))
#----------- ARIMA
library(tseries)
ar = auto.arima(IBOV, order=c(1,1,1))
library(timeSeries)
ar = auto.arima(IBOV, order=c(1,1,1))
ar = auto.arima(IBOV, lambda='auto')
library(forecast)
ar = auto.arima(IBOV, lambda='auto')
ar
ar = auto.arima(IBOV, c(1,1,1))
ar = auto.arima(IBOV, order=c(1,1,1))
ar = auto.arima(IBOV, start.p = 1)
auto.arima
ar
ar = auto.arima(IBOV, start.p = 1, start.q = 1)
ar
ar = auto.arima(IBOV, start.p = 1, start.q = 2)
ar
ar = auto.arima(IBOV, start.p = 3, start.q = 2)
ar
ar = auto.arima(IBOV, start.p = 2, start.q = 1)
ar
ar = auto.arima(IBOV, start.q = 1)
ar
ar
ar
ar = auto.arima(IBOV, start.q = 1)
ar
ar = auto.arima(IBOV, lambda = 'auto')
ar
fit = forecast(ar, h=10)
plot(fit)
plot(fit, dates)
library(tseries)
library(timeSeries)
library(forecast)   # auto.arima
library(quantmod)
library(fGarch)
getSymbols("^BVSP", src="yahoo", from="2010-01-01")
dates = index(BVSP)
IBOV = BVSP[1:2505 , 4]
View(IBOV)
View(IBOV)
plot( IBOV, type='l')
basicStats(IBOV)
ifelse(is.na(IBOV), mean(IBOV, na.rm=T ), IBOV)
IBOV = ifelse(is.na(IBOV), mean(IBOV, na.rm=T ), IBOV)
View(IBOV)
IBOV = BVSP[1:2505 , 4]
IBOV = xts(ifelse(is.na(IBOV), mean(IBOV, na.rm=T ), IBOV))
#-------------- GARCH
adf.test(IBOV)
na.omit(IBOV)
IBOV= na.omit(IBOV)
basicStats(IBOV)
adf.test(IBOV)
IBOV[1]
IBOV[2]
IBOV[1:5]
IBOV['new'] = diff(IBOV)
n = length(IBOV)
for (i in n) {
ret[i+1] = log(IBOV[i+1]/IBOV[i])
}
for (i in n){
print(i)
}
for (i in 1:n){
print(i)
}
n = length(IBOV)
for (i in 1:n) {
ret[i+1] = log(IBOV[i+1]/IBOV[i])
}
n = length(IBOV)
ret = c( )
for (i in 1:n) {
ret[i+1] = log(IBOV[i+1]/IBOV[i])
}
n = length(IBOV) + 1
ret = c( )
for (i in 1:n) {
ret[i+1] = log(IBOV[i+1]/IBOV[i])
}
ret = c( )
for (i in 1:n) {
if (i+1 =< n){
ret[i+1] = log(IBOV[i+1]/IBOV[i])
}
}
ret = c( )
for (i in 1:n) {
if (i+1 =< n){
ret[i+1] = log(IBOV[i+1]/IBOV[i])
}
}
ret = c( )
for (i in 1:n) {
if (i+1 < n){
ret[i+1] = log(IBOV[i+1]/IBOV[i])
}
}
ret
ret = rep(0,n )
for (i in 1:n) {
if (i+1 < n){
ret[i+1] = log(IBOV[i+1]/IBOV[i])
}
}
for (i in 2:n) {
if (i+1 < n){
ret[i+1] = log(IBOV[i+1]/IBOV[i])
}
}
rm(ret)
rm(ret)
for (i in 2:n) {
if (i+1 < n){
ret[i+1] = log(IBOV[i+1]/IBOV[i])
}
}
for (i in 2:n) {
if (i+1 < n){
ret = log(IBOV[i+1]/IBOV[i])
}
}
View(ret)
for (i in 1:n) {
if (i+1 < n){
ret = log(IBOV[i+1]/IBOV[i])
}
}
log(IBOV[1]/IBOV[1])
log(IBOV[2]/IBOV[1])
log(1/2)
IBOV[1]
IBOV[1]/IBOV[2]
bvcore = coredata(BVSP)
View(bvcore)
class(BVSP)
bvcore = index(dates)
View(bvcore)
bvcore = coredata(BVSP)
colnames(bvcore) = dates
rownames(bvcore) = dates
View(bvcore)
rownames(bvcore) = dates
bvcore[1, 4]
bvcore[1:5, 4]
bvcore[1:5, 4:2]
bvcore[1:5, 2:4]
bvcore[1:5, :4]
bvcore[1:5, 4:4]
bvcore[1:5, 4]
bvcore[1:5, :4]
bvcore[1:5, 4:]
bvcore[1:, 4]
bvcore = data.frame(bvcore)
View(bvcore)
rownames(bvcore) =  dates
View(bvcore)
bvcore[1:4, 1:4]
bvcore[1:4, 4]
names(bvcore)[4] = "IBOV"
View(bvcore)
bvcore[1: , 4]
bvcore[1:4, 4]
rm(ret)
bvcore[1:2505, 4]
IBOV = bvcore[1:2505, 4]
View(IBOV)
rm(IBOV)
bvcore <- bvcore[ ,4, drop=FALSE]
View(bvcore)
bvcore
bvcore[1]
bvcore[1]
bvcore[1]
bvcore[1]
bvcore[1:2]
bvcore[1:2, 1]
bvcore[1:1, 1]
bvcore[1, 1]
bvcore[2, 1]
bvcore[3, 1]
bvcore[3, 1]/bvcore[2, 1]
log(bvcore[3, 1]/bvcore[2, 1])
for (i in 1:n) {
if (i+1 < n){
bvcore$ret = log(bvcore[i+1, 1]/bvcore[i, 1])
}
}
View(bvcore)
for (i in 1:n) {
#if (i+1 < n){
bvcore$ret = log(bvcore[i+1, 1]/bvcore[i, 1])
}
View(bvcore)
for (i in 1:n){
print(i)
}
for (i in 1:n){
print(i)
}
log(bvcore[3, 1]/bvcore[2, 1])
log(bvcore[4, 1]/bvcore[3, 1])
for (i in 1:n) {
#if (i+1 < n){
bvcore$ret[i+1] = log(bvcore[i+1, 1]/bvcore[i, 1])
}
View(bvcore)
plot(bvcore[, 2])
plot(bvcore[ , 2], type='l')
plot(bvcore[ , 2], type='l', col='blue')
plot(bvcore[ , 2], type='l',
col='blue', ylab='Returns of IBOVESPA',
)
plot(bvcore[ , 2], type='l',
col='blue', ylab='Returns of IBOVESPA',
main='Evolution of Ibovespa returns')
shapiro.test(bvcore[ , 2])
View(bvcore)
plot(bvcore[ , 2], dates, type='l',
col='blue', ylab='Returns of IBOVESPA',
main='Evolution of Ibovespa returns')
plot(dates,bvcore[ , 2], type='l',
col='blue', ylab='Returns of IBOVESPA',
main='Evolution of Ibovespa returns')
hist(bvcore[ , 2])
hist(bvcore[ , 2], col = 'lightblue')
hist(bvcore[ , 2], col = 'lightblue', main = 'Histogram of IBOVESPA returns')
shapiro.test(bvcore[ , 2])
shapiro.test(bvcore[ , 2]) #The null-hypothesis of this test is that the population is normally distributed.
jarque.bera.test(bvcore[ , 2])
jarque.bera.test(omit.na(bvcore[ , 2]))
jarque.bera.test(na.omit(bvcore[ , 2]))
hist(bvcore[ , 2], col = 'lightblue', main = 'Histogram of IBOVESPA returns')curve(dnorm(x),add=T)
hist(bvcore[ , 2], col = 'lightblue', main = 'Histogram of IBOVESPA returns')
curve(dnorm(x),add=T)
hist(rnorm(1000))
curve(dnorm(x),add=T)
hist(rnorm(1000))
curve(dnorm(x),add=T)
hist(rnorm(1000), ylim=c(0,0.5))
curve(dnorm(x),add=T)
hist(rnorm(1000), probability = T)
curve(dnorm(x),add=T)
hist(bvcore[ , 2], col = 'lightblue', main = 'Histogram of IBOVESPA returns', probability = T)
curve(dnorm(x),add=T)
hist(bvcore[ , 2], col = 'lightblue', main = 'Histogram of IBOVESPA returns')
hist(bvcore[ , 2], col = 'lightblue', main = 'Histogram of IBOVESPA returns', density = T)
hist(bvcore[ , 2], col = 'lightblue', main = 'Histogram of IBOVESPA returns', probability = T)
curve(dnorm(x),add=T)
basicStats(bvcore[ , 2])
t.test(bvcore[ , 2], mu=0)
adf.test(bvcore[ , 2])
adf.test(na.omit(bvcore[ , 2]))
adf.test(na.omit(bvcore[ , 2]) )
bvcore[ , 2] = ifelse(is.na(bvcore[ , 2]), mean(bvcore[ , 2], na.rm=T ), bvcore[ , 2])
View(bvcore)
basicStats(bvcore[ , 2])
vol = garchFit(bvcore[ , 2] ~garch(1, 1), trace = FALSE)
summary(vol)
basicStats(bvcore[ , 2])
summary(vol)
fit =  fitted(vol)
plot(fit, type='l', col='blue', ylab='Volatilidade',
main='Volatilidade do IBOV usando o GARCH(1,1)')
plot(fit, type='l', col='blue', ylab='Volatilidade',
main='IBOV volatility using GARCH(1,1)')
ar = auto.arima(bvcore[ , 2], lambda = 'auto')
fit = forecast(ar, h=10)
plot(fit)
ar = auto.arima(bvcore[ , 2], lambda = 'auto')
fit = forecast(ar, h=30)
plot(fit)
library(mFilter)
filt = hpfilter(bvcore[ , 2])
filt = hpfilter(bvcore[ , 2], freq = 1600)
plot(filt)
#----------- ARIMA
acf(bvcore[ , 2])
pacf(bvcore[ , 2])
par(mfrow=c(1,2))
acf(bvcore[ , 2])
pacf(bvcore[ , 2])
acf(bvcore[ , 2], main='Return IBOV')
#----------- ARIMA
par(mfrow=c(1,2))
acf(bvcore[ , 2], main='Autocorrelation of IBOV returns')
pacf(bvcore[ , 2], main='Partial autocorrelation of IBOV returns')
#----------- ARIMA
window()
#----------- ARIMA
windows()
windows()
par(mfrow=c(1,2))
acf(bvcore[ , 2], main='Autocorrelation of IBOV returns')
pacf(bvcore[ , 2], main='Partial autocorrelation of IBOV returns')
ar = auto.arima(bvcore[ , 2], lambda = 'auto')
ar
54.5+543.95
54.5+543.95+1.55
1000*1.05
1000*0.05
5458.2+10*82.7
(5458.2+10*82.7)/76
35*94.4
99.8*10+96.55*13
(99.8*10+96.55*13)/23
(99.8*10+96.55*13+10*85.5+5*85.7+5*85.6+5*86)/48
(99.8*10+96.55*13+10*85.5+5*85.7+5*85.6+5*86+ 20*82)/68
(99.8*10+96.55*13+10*85.5+5*85.7+5*85.6+5*86+ 30*82)/68
(99.8*10+96.55*13+10*85.5+5*85.7+5*85.6+5*86+ 30*82)/78
(99.8*10+96.55*13+10*85.5+5*85.7+5*85.6+5*86+ 40*82)/78
(99.8*10+96.55*13+10*85.5+5*85.7+5*85.6+5*86+ 40*82)/88
(99.8*10+96.55*13+10*85.5+5*85.7+5*85.6+5*86+ 40*75)/88
(99.8*10+96.55*13+10*85.5+5*85.7+5*85.6+5*86+ 40*70)/88
source('D:/Git projects/ML in R/SVM_aplied_credit.R', echo=TRUE)
library(e1071)
clas = svm(formula= default ~., data=df_train, type= 'C-classification', kernel='linear')
summary(clas)
clas
prev = predict(clas, newdata = df_test[-4])
conf_matrix = table(prev, df_test[ ,4])
conf_matrix
conf_matrix = table(df_test[ ,4], prev)
conf_matrix
confusionMatrix(conf_matrix)
clas = svm(formula= default ~., data=df_train, type= 'C-classification', kernel='radial')
prev = predict(clas, newdata = df_test[-4])
conf_matrix = table(df_test[ ,4], prev)
conf_matrix
confusionMatrix(conf_matrix)
clas = svm(formula= default ~., data=df_train,
type= 'C-classification', kernel='radial', cost=5)
summary(clas)
prev = predict(clas, newdata = df_test[-4])
#------------ Confusion Matrix
conf_matrix = table(df_test[ ,4], prev)
conf_matrix
confusionMatrix(conf_matrix)
source('~/.active-rstudio-document', echo=TRUE)

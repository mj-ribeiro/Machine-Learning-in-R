e_t = 1
while(e_t !=0){
e_t = 0
for (i in length(s)){
s_cal = step(ent[i, ]%*%pes)
e = abs(s[i] - s_cal)
e_t = e_t + e
print(e_t)
for (j in length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
print(e_t)
}
}
}
#return(pes)
}
neural()
ent[4, ]%*%pes
ent[4, ]
s[4]
s[4] - scal
neural = function(){
e_t = 1
while(e_t !=0){
e_t = 0
for (i in length(s)){
s_cal = step(ent[i, ]%*%pes)
print(s_Cal)
e = abs(s[i] - s_cal)
e_t = e_t + e
print(e_t)
for (j in length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
print(e_t)
}
}
}
#return(pes)
}
neural()
neural = function(){
e_t = 1
while(e_t !=0){
e_t = 0
for (i in length(s)){
s_cal = step(ent[i, ]%*%pes)
print(s_cal)
e = abs(s[i] - s_cal)
e_t = e_t + e
print(e_t)
for (j in length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
print(e_t)
}
}
}
#return(pes)
}
neural()
neural = function(){
e_t = 1
while(e_t !=0){
e_t = 0
for (i in length(s)){
s_cal = step(ent[i, ]%*%pes)
print(s_cal)
e = abs(s[i] - s_cal)
e_t = e_t + e
for (j in length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
print(e_t)
}
}
}
#return(pes)
}
neural()
#### Neural network
length(s)
for(i in length(s)){
print(i)
}
neural = function(){
e_t = 1
while(e_t !=0){
e_t = 0
for (i in 1:length(s)){
s_cal = step(ent[i, ]%*%pes)
print(s_cal)
e = abs(s[i] - s_cal)
e_t = e_t + e
for (j in 1:length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
print(e_t)
}
}
}
#return(pes)
}
neural()
for(i in 1:length(s)){
print(i)
}
neural = function(){
e_t = 1
while(e_t !=0){
e_t = 0
for (i in 1:length(s)){
s_cal = step(ent[i, ]%*%pes)
print(s_cal)
e = abs(s[i] - s_cal)
e_t = e_t + e
for (j in 1:length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
print(e_t)
}
}
}
#return(pes)
}
neural()
neural()
neural()
step(ent[1, ]%*%pes)
step(ent[2, ]%*%pes)
step(ent[-2, ]%*%pes)
step(-1)
ent[2, ]%*%pes
ent[1, ]%*%pes
step = function(soma){
if (soma>=1) {
return(1)
}else{
return(0)
}
}
neural = function(){
e_t = 1
while(e_t !=0){
e_t = 0
for (i in 1:length(s)){
s_cal = step(ent[i, ]%*%pes)
print(s_cal)
e = abs(s[i] - s_cal)
e_t = e_t + e
for (j in 1:length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
print(e_t)
}
}
}
#return(pes)
}
neural()
neural = function(){
e_t = 1
while(e_t !=0){
e_t = 0
for (i in 1:length(s)){
s_cal = step(ent[i, ]%*%pes)
print(s_cal)
e = abs(s[i] - s_cal)
e_t = e_t + e
for (j in 1:length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
print(e_t)
}
}
}
return(pes)
}
neural()
neural = function(){
e_t = 1
while(e_t !=0){
e_t = 0
for (i in 1:length(s)){
s_cal = step(ent[i, ]%*%pes)
print(s_cal)
e = abs(s[i] - s_cal)
e_t = e_t + e
for (j in 1:length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
print(e_t)
}
}
}
print(pes)
}
neural()
print('olá')
print('olá', 4)
neural = function(){
e_t = 1
while(e_t !=0){
e_t = 0
for (i in 1:length(s)){
s_cal = step(ent[i, ]%*%pes)
print(s_cal)
e = abs(s[i] - s_cal)
e_t = e_t + e
for (j in 1:length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
print(e_t)
}
}
}
print('Os pesos são', pes)
}
neural()
print('pesos', pes)
print('pesos' pes)
print('pesos', 3)
cat('pesos', 3)
neural = function(){
e_t = 1
while(e_t !=0){
e_t = 0
for (i in 1:length(s)){
s_cal = step(ent[i, ]%*%pes)
e = abs(s[i] - s_cal)
e_t = e_t + e
for (j in 1:length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
print(e_t)
}
}
}
cat('Os pesos são', pes)
}
neural()
neural = function(){
e_t = 1
while(e_t !=0){
e_t = 0
for (i in 1:length(s)){
s_cal = step(ent[i, ]%*%pes)
e = abs(s[i] - s_cal)
e_t = e_t + e
for (j in 1:length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
}
}
}
cat('Os pesos são':, pes)
}
neural = function(){
e_t = 1
while(e_t !=0){
e_t = 0
for (i in 1:length(s)){
s_cal = step(ent[i, ]%*%pes)
e = abs(s[i] - s_cal)
e_t = e_t + e
for (j in 1:length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
print(e_t)
}
}
}
cat('Os pesos são':, pes)
}
neural = function(){
e_t = 1
while(e_t !=0){
e_t = 0
for (i in 1:length(s)){
s_cal = step(ent[i, ]%*%pes)
e = abs(s[i] - s_cal)
e_t = e_t + e
for (j in 1:length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
}
}
}
cat('Os pesos são:', pes)
}
neural()
#***************************************************************************
#                          Neural Network
#****************************************************************************
e1 = c(0, 0)
e2 = c(0, 1)
e3 = c(1, 0)
e4 = c(1, 1)
ent = rbind(e1, e2, e3, e4)
pes = c(0, 0)
s = c(0 , 0, 0, 1)
step = function(soma){
if (soma>=1) {
return(1)
}else{
return(0)
}
}
#### Neural network
neural = function(apr){
e_t = 1
while(e_t !=0){
e_t = 0
for (i in 1:length(s)){
s_cal = step(ent[i, ]%*%pes)
e = abs(s[i] - s_cal)
e_t = e_t + e
for (j in 1:length(pes)) {
pes[j] = pes[j] + apr * ent[i, j] * e
}
}
}
cat('Os pesos são:', pes)
}
neural(0.1)
neural(0.2)
neural(0.3)
neural(1)
neural(0.2)
neural(0.1)
121 - 74
47*12.7
11.44*60 + 12.35*61 - 47*12.7 +74*12.55
-11.44*60 - 12.35*61 + 47*12.7 + 74*12.55
-8.39 *99 + 8.49*99
-7.94*100 + 8.12*100
-8.50*100 + 9.3*100
-17.79*6 + 19.5*6
85+85+9.9+18+10.26
-8.12*100+8.78*100
install.packages(ctv)
install.packages('ctv')
install.packages('moments')
x1 = c(2, 1, 5, 7, 8, 0, 2, 1)
x1 = c(2, 1, 5, 7, 8, 0, 2, 1)
l = 0.5
x = cbind(x1, x2)
x = cbind(x1, x2)
x2 = c(11, 2, 4, 5, 78, 1, 2, 9)
x2 = c(11, 2, 4, 5, 78, 1, 2, 9)
x2 = c(11, 2, 4, 5, 78, 1, 2, 9)
x = cbind(x1, x2)
l = 0.5
y = c(1, 5, 2, 3, 7, 32, 2, 0)
b = t(t(x)%*%x)%*%t(x)%*%
b = t(t(x)%*%x)%*%t(x)%*%y
b = t(t(x)%*%x)%*%t(x)%*%y
b
b = inv(t(x)%*%x)%*%t(x)%*%y
install.packages("matlib")
library(matlib)
b = inv(t(x)%*%x)%*%t(x)%*%y
b
b = inv(t(x)%*%x + l )%*%t(x)%*%y
b
b = inv(t(x)%*%x + 1000 )%*%t(x)%*%y
b
reg = lm(y ~x1 + x2)
summary(reg)
b = inv(t(x)%*%x)%*%t(x)%*%y
b
reg = lm(y ~x1 + x2 - 1)
summary(reg)
b
137-133.89
133.189-138.5
-133.189+138.5
(-133.189+138.5)*5
(-133.189+138.99)*5
(16-4.8)/4.8
4.8/16
0.7*16
16-11.2
4.8*0.7
4.8*1.7
16/4.8
25.5/669.45
100*(25.5/669.45)
library(tseries)
library(timeSeries)
library(forecast)   # auto.arima
library(quantmod)
library(fGarch)
library(mFilter)
library(GetBCBData)   # get Bacen data
ibov = getSymbols('^BVSP', src='yahoo', from= '2007-01-01', auto.assign = F)[,4]
ibov = ibov[is.na(ibov)==F]
ib = vector(ibov)
ib = as.vector(ibov)
View(ib)
ib = as.xts(ib)
ib = as.xts(ib, error=T)
ib = as.xts(ib, error=F)
data = index(ibov)
ib = as.xts(ib, order.by = data)
View(ib)
rm(ib)
ret = diff(log(ibov))
plot(ret)
basicStats(ibov)
basicStats(ret)
basicStats(ibov)
basicStats(ret)
View(ibov)
colnames(ibov) = ibov
colnames(ibov)= c('ibov')
View(ibov)
colnames(ret) = c('ret')
basicStats(ibov)
basicStats(ret)
windows()
par(mfrow=c(3, 1))
plot(ibov, main='Evolution of IBOV')
plot(ret, main='Evolution of IBOV returns')
plot(ret^2, main='Evolution of square of IBOV returns')
plot(ret^2, auto.grid=F, main='Evolution of square of IBOV returns')
plot(ret^2, auto.grid=T, main='Evolution of square of IBOV returns')
plot(ret^2, main='Evolution of square of IBOV returns')
windows()
par(mfrow=c(3, 1))
plot(ibov, main='Evolution of IBOV')
plot(ret, main='Evolution of IBOV returns')
plot(ret^2, main='Evolution of square of IBOV returns')
ret = ret[is.na(ret)==F]  # Drop na to work
data = index(ret)
view(data)
View(data)
garch1 = garchFit(formula = ~garch(1,1),
data = ret)
summary(garch1)
vol = garch1@sigma.t
vol = as.xts(vol, charvec = data)
vol = as.xts(vol, order.by = data)
windows()
par(mfrow=c(2, 2))
plot(ibov, main='Evolution of IBOV')
plot(ret, main='Evolution of IBOV returns')
plot(ret^2, main='Evolution of square of IBOV returns')
plot(vol, main= 'Volatility GARCH(1,1)', type = 'l')
windows()
par(mfrow=c(2, 2))
plot(ibov, main='Evolution of IBOV')
plot(ret, main='Evolution of IBOV returns')
plot(ret^2, main='Evolution of square of IBOV returns')
plot(vol, main= 'Volatility of IBOV returns by GARCH(1,1)')
source('fcts/garch_fcts.R')
#*********************************************************************************
#                               GARCH
#*********************************************************************************
getwd()
#*********************************************************************************
#                               GARCH
#*********************************************************************************
setwd("D:/Git projects/R course")
source('fcts/garch_fcts.R')
source('garch_fcts.R')
source('garch_fcts.R')
source('fcts/garch_fcts.R')
# source functions
source('fcts/garch_fcts.R')
library(rugarch)
spec = ugarchspec()
spec
spec1 = ugarchspec(variance.model=list(model="sGARCH", garchOrder=c(1,1)),
mean.model=list(armaOrder=c(1,0), include.mean=TRUE),
distribution.model="norm", fixed.pars=list(omega=0))
garch2 = ugarchfit(spec = spec1, data= ret)
garch2
summary(garch1)
spec1 = ugarchspec(variance.model=list(model="sGARCH", garchOrder=c(1,1)),
mean.model=list(armaOrder=c(1,0), include.mean=TRUE),
distribution.model="norm")
garch2 = ugarchfit(spec = spec1, data= ret)
garch2
garch1
summary(garch2)
garch2
pred2 = ugarchforecast(garch2, n.ahead = 10)
plot(pred2)
pred2 = ugarchforecast(garch2, n.ahead = 5)
pred2
pred2 = pred2@forecast$sigmaFor
plot(pred2)
plot(pred2, type='l')
source('D:/Git projects/ML in R/neural_networks_aplied_credit.R', echo=TRUE)
install.packages("neuralnet")
library(neuralnet)
plot(clas, rep='best')
plot.nn(clas, rep='best')
library(devtools)
source_url('https://gist.githubusercontent.com/fawda123/7471137/raw/466c1474d0a505ff044412703516c34f1a4684a5/nnet_plot_update.r')
plot.nnet(clas)
T
Y
clas
w
plot.nnet(clas)
View(plot.nnet)
plot.nnet(clas)
rm(plot.nnet)
View(df_train)
NN = rede neural (default ~ income + loan + age, df_train, hidden = 3, linear.output = T)
NN = neuralnet(default ~ income + loan + age, df_train, hidden = 3, linear.output = T)
# traçar rede neural
plot (NN)
prev2 = predict(NN, df_test[, -4])
conf_matrix2 = table(df_test[,4], prev)
confusionMatrix(conf_matrix2)
NN = neuralnet(default ~ income + loan + age, df_train, hidden = 6, linear.output = T)
# traçar rede neural
plot (NN)
NN = neuralnet(default ~ income + loan + age, df_train, hidden = 4, linear.output = T)
NN = neuralnet(default ~ income + loan + age, df_train, hidden = 3, linear.output = T)
# traçar rede neural
plot (NN)
